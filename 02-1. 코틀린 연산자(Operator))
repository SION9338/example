수식의 구조

val result = num1 + num2
→ =: 대입 이항 연산자 , +:덧셈 이항 연산자, num1 + num2: 표현식

수식에 있는 덧셈(+)기호는 산술 연산자이고, num1, num2와 같이 연산에 사용되는 값은 항입니다.
이 때 연산자는 항의 개수에 따라서 단항 연산자(항이 1개), 이항 연산자(항이 2개), 삼항 연산자(항이 3개)로 구분합니다.

산술 연산자
사칙 연산자(+, -, *, /)와 나머지 연산자(%)를 산술 연산자라 부릅니다.
----------------------------------
if ((n % 2) == 1){ // 홀수로 만드는 식
  println("n is an Odd number") 
}
if ((n % 2) == 0){ // 짝수로 만드는 식
  println("n is an Even number")
}
------------------------------------

대입 연산자
대입 연산자(=)는 변수에 값을 할당하는 연산자입니다.
--------------------------------
num = num + 2 //산술 연산자와 대입 연산자를 함께 사용하는 경우
num += 2 // 이렇게 간략하게 표현
-------------------------------
첫 번째 코드와 두 번째 코드의 실행 결과는 같지만 실무에서는 간결하게 표현한 두 번째 방법을 더 선호함.

------------------------------
연산자 / 의미 / 사용 예
 = / 오른쪽 항의 내용을 왼쪽 항에 대입 / num = 2
+= / 두 항을 더한 후 왼쪽 항에 대입 / num += 2
-= / 왼쪽 항을 오른쪽 항으로 뺀 후 왼쪽 항에 대입 / num -= 2
*= / 두 항을 곱한 후 왼쪽 항에 대입 / num *= 2
/= / 왼쪽 항을 오른쪽 항으로 나눈 후 왼쪽 항에 대입 / num /= 2
%= / 왼쪽 항을 오른쪽 항으로 나머지 연산 후 왼쪽 항에 대입 / num %= 2
-----------------------------------

증감연산자
++ / 항의 값에 1 증가 / ++num 또는 num++
-- / 항의 값에 1 감소 / --num 또는 num--
--------------------------------------
*** 단, 증감 연산자는 항 앞에 붙이는 경우와 뒤에 붙이는 경우에 변수에 대입하면 변수에 저장되는 값이 각각 달라지므로 주의!!
fun main(){
    var num1 = 10
    var num2 = 10
    val result1 = ++num1 // num 값 증가 후 대입
    val result2 = num2++ // 먼저 num값 대입 후 증가

    println("result1: $result1") // 11
    println("result2: $result2") // 10
    println("num1: $num1") // 11
    println("num2: $num2") //11
}
-----------------------------------------------
fun main(){
    var num1 = 10
    var num2 = 10
    val result1 = --num1 // num 값 감소 후 대입
    val result2 = num2-- // 먼저 num값 감소 후 증가

    println("result1: $result1") // 9
    println("result2: $result2") // 10
    println("num1: $num1") // 9
    println("num2: $num2") //9
}
---------------------------------------------

비교 연산자
비교 연산자는 2개의 항을 비교하기 위해 사용합니다. 모든 비교 연산자는 비교 결과가 참이면 true를, 거짓이면 false를 반환합니다.

> / 왼쪽이 크면 true, 작으면 false 반환 / num > 2
< / 왼쪽이 작으면 true, 크면 false 반환 / num < 2
>= / 왼쪽이 크거나 같으면 true, 아니면 false / num >= 2
<= / 왼쪽이 작거나 같으면 true, 아니면 false / num <= 2
== / 두 항의 값이 같으면 ture, 아니면 false / num1 == num2
!= / 2개 항의 값이 다르면 true, 아니면 false / num1 != num2
=== / 2개 항의 참조 주소가 같으면 true, 아니면 false / num1 === num2       // 참조 주소가 같다고? 무슨 소리인지?
!== / 2개 항의 참조 주소가 다르면 true, 아니면 false / num1 !== num2      

****
삼중 등호 연산자 (===):

삼중 등호 연산자는 객체의 참조를 비교합니다. 객체가 같은 메모리 주소를 참조하는 경우에만 true를 반환하며, 값의 동일성이 아닌 객체의 동일성을 검사합니다.
예를 들어, a === b는 a와 b가 같은 객체를 가리키는지를 확인합니다.
=== 연산자는 코틀린에서 사용하는 특별한 연산자입니다. 자바에는 해당 연산자가 없습니다.

참조 주소:

객체가 생성될 때마다 해당 객체는 메모리 주소에 할당됩니다. 이 메모리 주소는 객체를 식별하는 유일한 값입니다.
참조 주소를 통해 서로 다른 객체와 같은 객체를 식별할 수 있습니다.
객체의 참조 주소는 hashCode() 메서드를 통해 얻을 수 있습니다.

예시:
fun main() {
    val a = "Hello"
    val b = "Hello"
    val c = a

    println(a === b) // false (다른 객체를 가리킴)  → 출력값이 true로 나옴... 왜냐?
    println(a === c) // true (같은 객체를 가리킴)
    println(a == b)  // true (값이 같음)

    println(a.hashCode()) // 해시 코드 출력 
}
---------------------------------------------------

→ 출력값이 true로 나옴... 왜냐?
→ '===' 연산자로 인한 출력값이 다 true로 나오는 이유는 코틀린에서 문자열 리터럴을 다루는 특수한 동작 때문입니다. 
문자열 리터럴은 컴파일러에 의해 관리되어 같은 값을 가지는 경우 동일한 메모리 주소를 참조하게 됩니다. 
이러한 최적화로 인해 === 연산자로 문자열 리터럴을 비교하면 true가 반환됩니다.
→ 아 그러니깐 출력값은 true로 나오지만 사실은 다른 객체이니깐 false인거다?
→ 네, 맞습니다. 출력값이 true로 나오더라도 실제로는 다른 객체입니다. 
코틀린에서는 문자열 리터럴을 다루는 특별한 최적화로 인해 문자열 리터럴은 동일한 값을 가진 경우 같은 객체를 참조하는 것처럼 보일 수 있습니다. 
그래서 === 연산자로 문자열 리터럴을 비교하면 true가 반환되지만, 사실상 두 개의 다른 객체입니다.
그러나 문자열을 객체 생성을 통해 만들 경우에는 별도의 객체가 생성되므로 === 연산자로 비교하면 false가 반환될 수 있습니다.
따라서 두 문자열이 실제로는 다른 객체일 수 있음에 주의하면 됩니다.

--------------------------------------------------------

논리연산자
논리 연산자에는 논리곱 연산자, 논리합 연산자, 부정 연산자가 있습니다.

&& / 논리곱으로 2개 항이 모두 true일 때, true, 아니면 false / exp1 && exp2

-------------------------------------------------------------------------------------------
|| / 논리합으로 2개 항 중 1개 항이 true일 때 true, 아니면 false / exp1 || exp2
fun main() {
    val a = true
    val b = false
    val result = a || b // 논리합 연산

    println(result) // true
}
----------------------------------------------------------------------------------------------
! / 부정 연산자로 true를 false로, flase를 true로 바꿈 / !exp
-------------------------------------------------------------------------------------

